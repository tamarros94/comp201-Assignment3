diff --git a/reader.ml b/reader.ml
index c4fd6b2..77c6fa2 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,5 +1,5 @@
-
 #use "pc.ml";;
+open PC;;
 
 exception X_not_yet_implemented;;
 exception X_this_should_not_happen;;
@@ -33,7 +33,8 @@ let rec sexpr_eq s1 s2 =
   | TagRef(name1), TagRef(name2) -> name1 = name2
   | _ -> false;;
   
-module Reader: sig
+module Reader 
+: sig
   val read_sexpr : string -> sexpr
   val read_sexprs : string -> sexpr list
 end
@@ -44,9 +45,367 @@ let normalize_scheme_symbol str =
 	(fun ch -> (ch = (lowercase_ascii ch)))
 	s) then str
   else Printf.sprintf "|%s|" str;;
+  
+(*abstract parsers*)
+(* abstract parser that skips nt_right and nt_left results from left and right of nt *)
+let make_paired nt_left nt_right nt =
+  let nt = caten nt_left nt in
+  let nt = pack nt (function (_, e) -> e) in
+  let nt = caten nt nt_right in
+  let nt = pack nt (function (e, _) -> e) in
+  nt;;
 
-let read_sexpr string = raise X_not_yet_implemented ;;
+(* 3.2.1 Whitespaces *)
+let nt_whitespace = const (fun ch -> ch <= ' ');;
+(* parser that skips whitesapes from left and right of nt *)
+let make_spaced nt = make_paired (star nt_whitespace) (star nt_whitespace) nt;;
+
+(* 3.2.2 Line comments *)
+let nt_comment_line = 
+    let nt_semicolon = char ';' in
+    let nt_eol = char (char_of_int 10) in
+    let nt_all_but_eol = diff nt_any nt_eol in
+    let nt_end_of_comment = disj nt_eol (pack nt_end_of_input (fun (dummy) -> 'd')) in
+    let nt = caten nt_semicolon (star nt_all_but_eol) in
+    let nt = caten nt nt_end_of_comment in
+    let nt = pack nt (fun e -> Nil) in
+    make_spaced nt;;
+    
+
+(*3.3.1 Boolean*)
+let nt_boolean =
+    let nt_hashtag = char '#' in
+    let nt_f = word_ci "f" in
+    let nt_t = word_ci "t" in
+    let nt_false = pack nt_f (fun f -> false) in
+    let nt_true = pack nt_t (fun t -> true) in
+    let nt = disj nt_false nt_true in
+    let nt = caten nt_hashtag nt in
+    (* let nt = pack nt (function (_, false) ->                     |TaggedSexpr(some_name, some_sexpr) -> if (name == some_name) && sexpr_eq some_sexpr sexpr
+(Bool false)) in  *)
+    let nt = pack nt (function (_0x, e) -> (Bool e)) in
+nt;;
+
+(*3.3.3 Symbol*)
+let digit = range '0' '9';;
+
+let nt_symbol =
+    let lowercase_letters = range 'a' 'z' in
+    let uppercase_letters = range 'A' 'Z' in
+    let punctuation = disj_list [char ':';char '!'; char '$'; char '^'; char '*'; char '-'; char '_'; char '='; char '+'; char '<'; char '>'; char '/'; char '?'] in    
+    let norm_uppercase = pack uppercase_letters lowercase_ascii in
+    let nt = disj_list [lowercase_letters; norm_uppercase; punctuation; digit] in
+    let nt = plus nt in
+    let nt = pack nt (fun e -> let str = list_to_string e in Symbol(str)) in
+    nt;;
+
+(*3.3.2 Number*)
+let not_digit = const (fun ch -> ch < '0' || ch > '9');;
+
+(*int*)
+let nt_int = 
+    let nt_body = pack (not_followed_by (plus digit) (char '.')) (function e -> int_of_string ((list_to_string e))) in
+    let nt_plus_op = char '+' in
+    let nt_minus_op = char '-' in
+    let nt_op = disj nt_minus_op nt_plus_op in
+    let nt_signed = pack (caten nt_op nt_body) 
+    (function (op,num) -> if (op = '-') then (-1)*(num) else num) in
+    let nt = disj nt_signed nt_body in
+    nt;;
+
+
+let nt_int_packed = 
+    let nt = not_followed_by nt_int nt_symbol in
+    pack nt (fun e -> Int(e));;
+ 
+(*float*)
+let nt_float =
+    let nt_dot = char '.' in
+    let nt_form = caten (plus digit) (caten nt_dot (plus digit)) in
+    let nt_body = pack nt_form 
+    (function (a,(b, c)) -> float_of_string ((list_to_string a) ^ "." ^ (list_to_string c))) in
+    let nt_plus_op = char '+' in
+    let nt_minus_op = char '-' in
+    let nt_op = disj nt_minus_op nt_plus_op in
+    let nt_signed = pack (caten nt_op nt_body) 
+    (function (op,num) -> if (op = '-') then (-1.0)*.(num) else num) in
+    let nt = disj nt_signed nt_body in
+    nt;;
+    (*number*)
+
+let nt_float_packed = 
+    let nt_symbols_not_e = diff nt_symbol (word_ci "e") in
+    let nt = not_followed_by nt_float nt_symbols_not_e in
+    pack nt (fun e -> Float(e));;
+    
+    (*number*)
+
+(*4.1 Scientific notation*)
+let nt_scientific_notation = 
+    let nt_int_to_float = pack nt_int (fun e -> float_of_int e) in
+    let nt = disj nt_int_to_float nt_float in
+    let nt_e = word_ci "e" in
+    let nt = caten nt (caten nt_e nt_int_to_float) in
+    (* let nt = not_followed_by nt nt_symbol in *)
+    let nt = pack nt (fun (num, (e, exp)) -> let n = num *. (10. ** exp) in Float(n)) in
+    nt;;
+
+
+let make_nt_digit ch_from ch_to displacement =
+    let nt = const (fun ch -> ch_from <= ch && ch <= ch_to) in
+    let nt = pack nt (let delta = (Char.code ch_from) - displacement in
+		      fun ch -> (Char.code ch) - delta) in
+    nt;;
+
+let nt_radix_cal radix =
+  let nt = disj (make_nt_digit '0' '9' 0)
+		(make_nt_digit 'a' 'z' 10) in
+  let nt = disj nt (make_nt_digit 'A' 'Z' 10) in
+  let nt = plus nt in
+  let nt = pack nt (fun digits ->
+		    List.fold_left (fun a b -> radix * a + b) 0 digits) in
+  nt;;
+
+let nt_radix_cal_float radix =
+  let nt = disj (make_nt_digit '0' '9' 0)
+		(make_nt_digit 'a' 'z' 10) in
+  let nt = disj nt (make_nt_digit 'A' 'Z' 10) in
+  let nt = pack nt (fun e -> float_of_int e) in
+  let nt = plus nt in
+  (* let nt = pack nt (fun digits -> (1./.(float_of_int radix))) in   *)
+  let nt = pack nt (fun digits -> List.fold_right (fun a b -> (1./.(float_of_int radix)) *. (b +. a)) digits 0.) in  
+  nt;;
+
+let nt_radix_range = disj_list [digit; range 'a' 'z'; range 'A' 'Z'] ;;
+
+let nt_radix_identifier = 
+    let nt_hashtag = char '#' in
+    let nt_r = disj (char 'r') (char 'R') in
+    let body_until_r = caten nt_hashtag (caten nt_int nt_r) in
+
+    let nt_plus_op = char '+' in
+    let nt_minus_op = char '-' in
+    let nt_op = disj nt_minus_op nt_plus_op in
+    let nt_signed = caten body_until_r nt_op in 
+    let nt_signed = pack nt_signed (fun ((_hash, (base,r)), op) -> (op,(_hash, (base,r)))) in
+
+    let nt = disj nt_signed (pack body_until_r (fun (_hash, (base,r)) -> ('+',(_hash, (base,r))))) in
+    let nt = pack nt (fun (op, (_hash, (base,_r))) -> (op, base)) in
+    nt;;
+
+let nt_int_radix = 
+    let nt = not_followed_by (plus nt_radix_range) (char '.') in
+    let nt = caten nt_radix_identifier nt in
+    let nt = pack nt (fun ((op,base), num) -> (op, (nt_radix_cal base num))) in
+    let nt = pack nt (fun (op, (num,_)) -> if (op = '-') then (-1)*(num) else num) in
+    let nt = pack nt (fun (num) -> Int(num)) in
+    nt;;
+
+let nt_float_radix = 
+    let nt_form = caten (plus nt_radix_range) (caten (char '.') (plus nt_radix_range)) in
+    let nt = pack nt_form (fun (a, (_, b)) -> (a,b)) in
+    let nt = caten nt_radix_identifier nt in
+    let nt = pack nt (fun ((op,base), (left, right)) -> 
+    let converted_left = nt_radix_cal base left  in
+    let converted_right = nt_radix_cal_float base right in
+    (op,(converted_left, converted_right))) in
+    let nt = pack nt (fun (op,((e1,_),(e2,_))) -> 
+        let converted = (float_of_int e1) +. e2 in
+        (op, converted)) in
+    let nt = pack nt (fun (op, num) -> if (op = '-') then (-1.)*.(num) else num) in
+    let nt = pack nt (fun num -> Float(num)) in
+    nt;;
+
+let nt_number = 
+    let nt = disj_list [nt_float_radix;nt_int_radix;nt_scientific_notation;nt_float_packed; nt_int_packed] in
+    let nt = pack nt (function e -> Number(e)) in
+    nt;;
+
+(*3.3.4 String*)
+let nt_string = 
+    let string_literal_char = diff nt_any (disj (char (char_of_int 34)) (char (char_of_int 92))) in
+    let string_meta_char = disj_list [
+        pack (word "\\\\") (fun e -> char_of_int 92);
+        pack (word "\\\"") (fun e -> char_of_int 34);
+        pack (word "\\t") (fun e -> char_of_int 9);
+        pack (word "\\f") (fun e -> char_of_int 12);
+        pack (word "\\n") (fun e -> char_of_int 10);
+        pack (word "\\r") (fun e -> char_of_int 13)
+        ] in
+    let nt_body = disj string_literal_char string_meta_char in
+    let nt_double_quote = char (char_of_int (34)) in
+    let nt = caten nt_double_quote (caten (star nt_body) nt_double_quote) in
+    let nt = pack nt (fun (_, (e, _)) -> String(list_to_string e)) in
+    nt;;
+
+(*3.3.5 Char*)
+let nt_char =
+    let char_prefix = caten (char '#') (char '\\') in
+    let visible_simple_char = const (fun ch -> (int_of_char ch) > 32) in
+    let named_char = disj_list [
+        pack (word_ci "nul") (fun e -> char_of_int 0);
+        pack (word_ci "newline") (fun e -> char_of_int 10);
+        pack (word_ci "return") (fun e -> char_of_int 13);
+        pack (word_ci "tab") (fun e -> char_of_int 9);
+        pack (word_ci "page") (fun e -> char_of_int 12);
+        pack (word_ci "space") (fun e -> char_of_int 32)
+        ] in
+    let nt = disj named_char visible_simple_char in
+    let nt = pack (caten char_prefix nt) (fun (_, e) -> Char(e)) in
+    nt;;
+
+let nt_teg_ref_identifier= 
+    let prefix = word "#{" in
+    let postfix = word "}" in
+    let symbol_name = pack nt_symbol (
+        function e -> match e with
+        | Symbol(name) -> name
+        | other_sexpr -> raise X_no_match ) in
+    let nt = caten prefix (caten (symbol_name) postfix) in
+    let nt = pack nt (fun (_, (name, _)) -> name) in
+    nt;;
+
+let rec fun1 acc_list original_list = 
+    match original_list with
+    |Pair(sexpr1, sexpr2) -> let a = (List.append (fun1 acc_list sexpr1) acc_list) in let b = (List.append (fun1 acc_list sexpr2) acc_list) in List.append a b
+    |TaggedSexpr(name, sexpr) -> List.append [TaggedSexpr(name, sexpr)] acc_list
+    |other -> acc_list
+
+let fun2 lst = 
+    let rec same_tag_exists_in_list compare_name tag_list = match tag_list with
+        | TaggedSexpr(name, sexpr) :: rest_of_list -> if name = compare_name then true else same_tag_exists_in_list compare_name rest_of_list 
+        | other -> false in
+
+    let rec choose_tag tag_list =
+        match tag_list with
+        | TaggedSexpr(name, sexpr) :: rest_of_list -> if (same_tag_exists_in_list name rest_of_list) then false else choose_tag rest_of_list
+        | other -> true in
+
+        choose_tag lst;;
+
+
+let check_if_valid_list paired_list =
+let lst = [] in
+let tag_list = fun1 lst paired_list in
+let is_valid = fun2 tag_list in
+         if is_valid then paired_list else raise X_this_should_not_happen;;
+(* sexp *)
+
+let rec nt_sexpr str = 
+    let sexpr_disj = disj_list [
+            nt_boolean;
+            nt_char;
+            nt_number;
+            nt_string;
+            nt_symbol;
+            nt_nil;
+            nt_list;
+            nt_dotted_list;
+            nt_quote;
+            nt_quasi_quote;
+            nt_unquote;
+            nt_unquote_and_splice;
+            nt_tagged_sexpr;
+            nt_tag_ref
+           ] in
+    (make_spaced_or_commented sexpr_disj) str
+    and nt_list s = 
+        let prefix = char '(' in
+        let postfix = char ')' in
+        let body = star nt_sexpr in
+        let nt = caten prefix (caten body postfix) in
+        let nt = pack nt (
+            function (_,(e,_)) -> match e with
+            |[] -> Nil
+            |lst -> List.fold_right (fun sexpr1 sexpr2 -> Pair(sexpr1, sexpr2)) lst Nil
+        ) in
+        let nt = (pack nt check_if_valid_list) in
+         nt s
+    and nt_dotted_list s = 
+        let prefix = char '(' in
+        let postfix = char ')' in
+        let nt_dot = char '.' in
+        let body = caten (plus nt_sexpr) (caten nt_dot nt_sexpr) in
+        let nt = caten prefix (caten body postfix) in
+        let nt = pack nt (
+            function (_,(e,_)) -> match e with
+            |(a, (_, b)) -> List.fold_right (fun sexpr1 sexpr2 -> Pair(sexpr1, sexpr2)) a b
+        )in
+        let nt = (pack nt check_if_valid_list) in
+            nt s
+    and nt_quote s = 
+        let prefix = word "'" in
+        let nt = caten prefix nt_sexpr in
+        pack nt (function (_, e) -> Pair(Symbol("quote"), Pair(e, Nil)))
+        s
+    and nt_quasi_quote s = 
+        let prefix = word "`" in
+        let nt = caten prefix nt_sexpr in
+        pack nt (function (_, e) -> Pair(Symbol("quasiquote"), Pair(e, Nil)))
+        s
+    and nt_unquote s = 
+        let prefix = word "," in
+        let nt = caten prefix nt_sexpr in
+        pack nt (function (_, e) -> Pair(Symbol("unquote"), Pair(e, Nil)))
+        s
+    and nt_unquote_and_splice s = 
+        let prefix = word ",@" in
+        let nt = caten prefix nt_sexpr in
+        pack nt (function (_, e) -> Pair(Symbol("unquote-splicing"), Pair(e, Nil)))
+        s
+    and nt_tag_ref s =
+        let nt = pack nt_teg_ref_identifier (fun name -> TagRef(name)) in
+        nt s
+    and nt_tagged_sexpr s =
+        let eq_sign = word "=" in
+        let nt = caten nt_teg_ref_identifier eq_sign in
+        let nt = caten nt nt_sexpr in
+        let nt = pack nt (fun ((name,_),sexpr) -> TaggedSexpr(name, sexpr)) in
+        let nt = pack nt (fun e -> 
+            let rec check_if_valid original_name rec_sexpr = match rec_sexpr with
+                |TaggedSexpr(some_name, some_sexpr) -> 
+                    if some_name = original_name 
+                        then false
+                        else (check_if_valid original_name some_sexpr)
+                |Pair(sexpr1, sexpr2) -> 
+                    (check_if_valid original_name sexpr1) &&
+                    (check_if_valid original_name sexpr2) 
+                |other -> true in
+
+            match e with
+            | TaggedSexpr(name, sexpr) -> let valid = check_if_valid name sexpr in
+            if valid then TaggedSexpr(name, sexpr) else raise X_this_should_not_happen
+            | other -> raise X_no_match ) in
+            nt s
+    and nt_comment_sexpr s =
+        let prefix = word "#;" in
+        let body = nt_sexpr in
+        let nt = caten prefix body in
+        (pack nt (fun e -> Nil)) 
+        s
+    and nt_nil s = 
+        let prefix = char '(' in
+        let postfix = char ')' in
+        let body = disj_list [nt_comment_line; (pack nt_whitespace (fun e -> Nil));nt_comment_sexpr] in
+        let nt = caten prefix (caten (star body) postfix) in
+        let nt = pack nt (fun e -> Nil) in
+        nt s
+    and make_spaced_or_commented s = 
+        (* let nt_not_last_comment_sexpr = not_followed_by (pack nt_comment_sexpr (fun e -> Nil)) (pack (nt_end_of_input) (fun e -> Nil)) in *)
+        let whitespace_or_comment = disj_list [(pack nt_whitespace (fun e -> Nil));nt_comment_line;nt_comment_sexpr] in
+        let nt1 nt = make_paired (star whitespace_or_comment) (star whitespace_or_comment) nt in
+        nt1 s;;
+
+
+let read_sexpr string =
+  let (sexpr, s) = (nt_sexpr (string_to_list string)) in
+  if (s = [])
+  then sexpr
+  else raise X_no_match;;
+
+
+let read_sexprs string =
+    let (sexpr_list, s) = ((star nt_sexpr) (string_to_list string)) in
+    sexpr_list;;
 
-let read_sexprs string = raise X_not_yet_implemented;;
-  
 end;; (* struct Reader *)
diff --git a/readme.txt b/readme.txt
index e69de29..60a6f31 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,10 @@
+Tamar Rosen 312275845
+Ronen Krishtal 311303572
+
+We assert that the work we submitted is 100% our own. We have not received any
+part from any other student in the class, nor have we give parts of it for use to others.
+Nor have we used code from other sources: Courses taught previously at this university,
+courses taught at other universities, various bits of code found on the Internet, etc.
+We realize that should our code be found to contain code from other sources, that a
+formal case shall be opened against us with va’adat mishma’at, in pursuit of disciplinary
+action.
\ No newline at end of file
diff --git a/semantic-analyser.ml b/semantic-analyser.ml
index 2f5ff59..6fa151d 100644
--- a/semantic-analyser.ml
+++ b/semantic-analyser.ml
@@ -52,24 +52,391 @@ let rec expr'_eq e1 e2 =
                        
 exception X_syntax_error;;
 
-module type SEMANTICS = sig
+module type SEMANTICS = 
+sig
   val run_semantics : expr -> expr'
   val annotate_lexical_addresses : expr -> expr'
   val annotate_tail_calls : expr' -> expr'
   val box_set : expr' -> expr'
 end;;
 
-module Semantics : SEMANTICS = struct
+module Semantics 
+: SEMANTICS 
+= struct
+      
+let rec annotate_bound_major string_var arg_lists major_level = 
+  let rec annotate_bound_minor string_var arg_list minor_level = match arg_list with
+  | car :: cdr -> if String.equal car string_var then Some(minor_level) else annotate_bound_minor string_var cdr (minor_level + 1)
+  | _ -> None in
 
-let annotate_lexical_addresses e = raise X_not_yet_implemented;;
+match arg_lists with
+| [arg_list :: cdr] -> let minor = annotate_bound_minor string_var arg_list 0 in (match minor with 
+   | Some(minor_level) -> if (major_level < 0) then Var'(VarParam(string_var, minor_level)) else Var'(VarBound(string_var, major_level, minor_level))
+   | None -> annotate_bound_major string_var [cdr] (major_level + 1))
+| _ -> Var'(VarFree(string_var))
+ ;;
 
-let annotate_tail_calls e = raise X_not_yet_implemented;;
+let rec annotate_lexical_rec e = match e with
+  | Const(constant) -> Const'(constant)
+  | Var(string) -> Var'(VarFree(string))
+  | If(test, dit, dif) -> If'(annotate_lexical_rec test, annotate_lexical_rec dit, annotate_lexical_rec dif)
+  | Seq(expr_list) -> Seq'(List.map annotate_lexical_rec expr_list)
+  | Set(expr_var, expr_val) -> Set'(annotate_lexical_rec expr_var,annotate_lexical_rec expr_val)
+  | Def(expr_var, expr_val) -> Def'(annotate_lexical_rec expr_var,annotate_lexical_rec expr_val)
+  | Or(expr_list) -> Or'(List.map annotate_lexical_rec expr_list)
+  | Applic(expr, expr_list) -> Applic'(annotate_lexical_rec expr,List.map annotate_lexical_rec expr_list)
+  | LambdaSimple(arg_list, body) -> let annotated_body = (annotate_lambda_simple [arg_list] body) in LambdaSimple'(arg_list,annotated_body)
+  | LambdaOpt(arg_list, opt_arg, body) -> let annotated_body = annotate_lambda_simple [arg_list@[opt_arg]] body in 
+  LambdaOpt'(arg_list, opt_arg, annotated_body)
 
-let box_set e = raise X_not_yet_implemented;;
+  and annotate_lambda_simple arg_lists body = match body with
+  | Const(constant) -> Const'(constant)
+  | Var(str) -> annotate_bound_major str [arg_lists] (-1)
+  | If(test, dit, dif) -> If'(annotate_lambda_simple arg_lists test, annotate_lambda_simple arg_lists dit, annotate_lambda_simple arg_lists dif)
+  | Seq(expr_list) -> Seq'(List.map (annotate_lambda_simple arg_lists) expr_list)
+  | Set(expr_var, expr_val) -> Set'(annotate_lambda_simple arg_lists expr_var,annotate_lambda_simple arg_lists expr_val)
+  | Def(expr_var, expr_val) -> Def'(annotate_lambda_simple arg_lists expr_var,annotate_lambda_simple arg_lists expr_val)
+  | Or(expr_list) -> Or'(List.map (annotate_lambda_simple arg_lists) expr_list)
+  | Applic(expr, expr_list) -> Applic'(annotate_lambda_simple arg_lists expr,List.map (annotate_lambda_simple arg_lists) expr_list)
+  | LambdaSimple(arg_list, inner_body) -> let annotated_body = annotate_lambda_simple ([arg_list]@arg_lists) inner_body in LambdaSimple'(arg_list,annotated_body)
+  | LambdaOpt(arg_list, opt_arg, inner_body) -> let annotated_body = annotate_lambda_simple ([arg_list @ [opt_arg]]@arg_lists) inner_body 
+  in  LambdaOpt'(arg_list, opt_arg, annotated_body)
+  ;;
+
+let rec annotate_tail_rec in_tp e = match e with
+  | If'(test, dit, dif) -> If'(annotate_tail_rec false test, annotate_tail_rec in_tp dit, annotate_tail_rec in_tp dif)
+  | Seq'(expr_list) -> annotate_seq in_tp expr_list
+  | Set'(expr_var, expr_val) -> Set'(annotate_tail_rec false expr_var,annotate_tail_rec false expr_val)
+  | Def'(expr_var, expr_val) -> Def'(annotate_tail_rec false expr_var,annotate_tail_rec false expr_val)
+  | Or'(expr_list) -> annotate_or in_tp expr_list
+  | Applic'(expr, expr_list) -> if in_tp then ApplicTP'(annotate_tail_rec false expr,List.map (annotate_tail_rec false) expr_list) else Applic'(annotate_tail_rec false expr,List.map (annotate_tail_rec false) expr_list)
+  | LambdaSimple'(arg_list, body) -> LambdaSimple'(arg_list, annotate_tail_rec true body)
+  | LambdaOpt'(arg_list, opt_arg, body) -> LambdaOpt'(arg_list, opt_arg, annotate_tail_rec true body)
+  | other -> other
+
+and annotate_seq in_tp expr_list = (match (List.rev expr_list) with 
+    | car :: cdr -> Seq'((List.map (annotate_tail_rec false) (List.rev cdr)) @ [(annotate_tail_rec in_tp car)])
+    | _ -> Seq'((List.map (annotate_tail_rec false) expr_list)))
+
+and annotate_or in_tp expr_list = (match (List.rev expr_list) with 
+    | car :: cdr -> Or'((List.map (annotate_tail_rec false) (List.rev cdr)) @ [(annotate_tail_rec in_tp car)])
+    | _ -> Or'((List.map (annotate_tail_rec false) expr_list)))
+
+
+let rec append_list l1 l2 =
+    match l1 with
+    | [] -> l2
+    | h::t -> if List.mem h l2 then append_list t l2
+              else append_list t (h::l2);;
+
+let append_inner_lists l1 l2 = match l1, l2 with
+| left1::[right1], left2::[right2] -> [append_list left1 left2;append_list right1 right2]
+|(l1, []) -> l1
+|([], l2) -> l2
+| other -> [];;
+
+let rec print_list = function 
+[] -> ()
+| e::l -> print_int e ; print_string " " ; print_list l;;
+
+  type counter = { get : unit -> int;
+                     incr : unit -> unit };;
+
+let find_fathers minor arg body = 
+
+  let father_id =
+    let n = ref 0 in
+    { get = (fun () -> !n);
+      incr = (fun () -> n:= !n +1) } in
+
+  let rec find_rw_fathers level arg body = 
+    (* Printf.printf "father %d level %d arg %s\n" (father_id.get ()) level arg; *)
+    match body with
+    | Var'(VarParam(str, minor)) -> if level = (-1) 
+      then if String.equal str arg then [[-1];[]] else [[];[]]
+      else [[];[]]
+
+    | Var'(VarBound(str, major, minor)) -> if level = major
+      then if String.equal str arg then [[(father_id.get ())];[]] else [[];[]]
+      else [[];[]]
+
+    | Set'(var, expr) -> 
+      (match var, expr with
+      | Var'(VarParam(str1, minor1)), Var'(VarParam(str2, minor2)) -> if level = (-1)
+        then if String.equal str1 arg 
+            then if String.equal str2 arg then [[-1];[-1]] else [[];[-1]]
+            else if String.equal str2 arg then [[-1];[]] else [[];[]]
+        else [[];[]]
+      | Var'(VarBound(str1, major1, minor1)), Var'(VarBound(str2, major2, minor2)) -> 
+        if level = major1
+              (*write matches level*)
+              then if String.equal str1 arg 
+                    (*write matches name*)
+                    then if level = major2 
+                        (*read matches level*)
+                        then if String.equal str2 arg then [[(father_id.get ())];[(father_id.get ())]] else [[];[(father_id.get ())]]
+                        (*read doesn't matches level*)
+                        else [[];[(father_id.get ())]]
+                    (*write doesn't name*)
+                    else if level = major2 
+                        (*read matches level*)
+                        then if String.equal str2 arg then [[(father_id.get ())];[]] else [[];[]]
+                        (*read doesn't matches level*)
+                        else [[];[]]
+              (*write doesn't matches level*)
+              else if level = major2 
+                        (*read matches level*)
+                        then if String.equal str2 arg then [[(father_id.get ())];[]] else [[];[]]
+                        (*read doesn't matches level*)
+                        else [[];[]]
+      | Var'(VarBound(str1, major, minor1)), Var'(VarParam(str2, minor2)) ->  if level = major
+            (*write matches level*)
+            then if String.equal str1 arg 
+                  (*write matches name*)
+                  then [[];[(father_id.get ())]]
+                  (*write doesn't match name*)
+                  else [[];[]]
+            (*write doesn't matches level*)
+            else [[];[]]
+      | Var'(VarParam(str1, minor1)), Var'(VarBound(str2, major, minor2)) -> if level = major
+            (*read matches level*)
+            then if String.equal str2 arg 
+                  (*read matches name*)
+                  then [[(father_id.get ())];[]]
+                  (*read doesn't match name*)
+                  else [[];[]]
+            (*read doesn't matches level*)
+            else [[];[]]
+      | Var'(VarParam(str, minor)), not_var -> if level = -1
+        (*write matches level*)
+        then if String.equal str arg 
+              (*write matches name*)
+              then let result = find_rw_fathers level arg not_var in match result with
+              | read_list::[write_list] -> [read_list;[-1]@write_list]
+              | other -> other
+              (*write doesn't matches name*)
+              else find_rw_fathers level arg not_var
+        (*write doesn't matches level*)
+        else find_rw_fathers level arg not_var
+      | Var'(VarBound(str, major,minor)), not_var -> 
+      if level = major
+        (*write matches level*)
+        then if String.equal str arg 
+              (*write matches name*)
+              then let result = find_rw_fathers level arg not_var in  match result with
+              | read_list::[write_list] -> [read_list;[(father_id.get ())]@write_list]
+              | other -> other
+              (*write doesn't matches name*)
+              else find_rw_fathers level arg not_var
+        (*write doesn't matches level*)
+        else find_rw_fathers level arg not_var
+      | Var'(VarFree(str)), expr -> find_rw_fathers level arg expr
+      | other -> [[];[]]
+      )
+
+    | If'(test, dit, dif) -> 
+      let fathers_test = find_rw_fathers level arg test in
+      let fathers_dit = find_rw_fathers level arg dit in
+      let fathers_dif = find_rw_fathers level arg dif in
+      (match fathers_test, fathers_dit, fathers_dif with
+      | [read_test;write_test],[read_dit;write_dit],[read_dif;write_dif] ->  [read_test@read_dit@read_dif;write_test@write_dit@write_dif]
+      | other -> [[];[]])
+
+    | Seq'(expr_list) -> 
+      let expr_list_rec = List.map (find_rw_fathers level arg) expr_list in
+      List.fold_right append_inner_lists expr_list_rec []
+    | Or'(expr_list) -> 
+      let expr_list_rec = List.map (find_rw_fathers level arg) expr_list in
+      List.fold_right append_inner_lists expr_list_rec []
+    | Applic'(expr, expr_list) -> 
+      let expr_rec = find_rw_fathers level arg expr in
+      let expr_list_rec = List.map (find_rw_fathers level arg) expr_list in
+      let expr_list_appended = List.fold_right append_inner_lists expr_list_rec [] in
+      append_inner_lists expr_rec expr_list_appended
+    | ApplicTP'(expr, expr_list) -> 
+      let expr_rec = find_rw_fathers level arg expr in
+      let expr_list_rec = List.map (find_rw_fathers level arg) expr_list in
+      let expr_list_appended = List.fold_right append_inner_lists expr_list_rec [] in
+      append_inner_lists expr_rec expr_list_appended
+    | LambdaSimple'(arg_list, inner_body) -> if level = (-1) then father_id.incr (); find_rw_fathers (level + 1) arg inner_body
+    | LambdaOpt'(arg_list, opt_arg, inner_body) -> if level = (-1) then father_id.incr (); find_rw_fathers (level + 1) arg inner_body
+    | Def'(expr_var, expr_val) -> raise X_syntax_error
+    | other -> [[];[]]  in
+
+  find_rw_fathers (-1) arg body;;
+
+  
+let rec box_get_set_body level arg body = 
+match body with
+    | Var'(VarParam(str, minor)) -> if level = (-1) 
+      then if String.equal str arg then BoxGet'(VarParam(str, minor)) else body
+      else body
+
+    | Var'(VarBound(str, major, minor)) -> 
+    if level = major
+      then if String.equal str arg then BoxGet'(VarBound(str, major, minor)) else body
+      else body
+
+    | Set'(var, expr) -> 
+      (match var, expr with
+      | Var'(VarParam(str1, minor1)), Var'(VarParam(str2, minor2)) -> if level = (-1)
+        then if String.equal str1 arg 
+            then if String.equal str2 arg then BoxSet'(VarParam(str1, minor1), BoxGet'(VarParam(str2, minor2))) else BoxSet'(VarParam(str1, minor1), expr)
+            else if String.equal str2 arg then Set'(var, BoxGet'(VarParam(str2, minor2))) else body
+        else body
+      | Var'(VarBound(str1, major1, minor1)), Var'(VarBound(str2, major2, minor2)) -> 
+        if level = major1
+              (*write matches level*)
+              then if String.equal str1 arg 
+                    (*write matches name*)
+                    then if level = major2 
+                        (*read matches level*)
+                        then if String.equal str2 arg then BoxSet'(VarBound(str1, major1, minor1), BoxGet'(VarBound(str2, major2, minor2))) else BoxSet'(VarBound(str1, major1, minor1), expr)
+                        (*read doesn't matches level*)
+                        else BoxSet'(VarBound(str1, major1, minor1), expr)
+                    (*write doesn't match name*)
+                    else if level = major2 
+                        (*read matches level*)
+                        then if String.equal str2 arg then Set'(var, BoxGet'(VarBound(str2, major2, minor2))) else body
+                        (*read doesn't matches level*)
+                        else body
+              (*write doesn't matches level*)
+              else if level = major2 
+                        (*read matches level*)
+                        then if String.equal str2 arg then Set'(var, BoxGet'(VarBound(str2, major2, minor2))) else body
+                        (*read doesn't matches level*)
+                        else body
+      | Var'(VarBound(str1, major, minor1)), Var'(VarParam(str2, minor2)) ->  if level = major
+            (*write matches level*)
+            then if String.equal str1 arg 
+                  (*write matches name*)
+                  then BoxSet'(VarBound(str1, major, minor1), expr)
+                  (*write doesn't match name*)
+                  else body
+            (*write doesn't matches level*)
+            else body
+      | Var'(VarParam(str1, minor1)), Var'(VarBound(str2, major, minor2)) -> if level = major
+            (*read matches level*)
+            then if String.equal str2 arg 
+                  (*read matches name*)
+                  then Set'(var, BoxGet'(VarBound(str2, major, minor2)))
+                  (*read doesn't match name*)
+                  else body
+            (*read doesn't matches level*)
+            else body
+      | Var'(VarParam(str, minor)), not_var -> 
+        let result_body = box_get_set_body level arg not_var in
+        if level = -1
+        (*write matches level*)
+        then if String.equal str arg 
+              (*write matches name*)
+              then BoxSet'(VarParam(str, minor), result_body)
+              (*write doesn't matches name*)
+              else Set'(var, result_body)
+        (*write doesn't matches level*)
+        else Set'(var, result_body)
+      | Var'(VarBound(str, major,minor)), not_var -> 
+        let result_body = box_get_set_body level arg not_var in
+        if level = major
+        (*write matches level*)
+        then if String.equal str arg 
+              (*write matches name*)
+              then BoxSet'(VarBound(str, major,minor), result_body)
+              (*write doesn't matches name*)
+              else Set'(var, result_body)
+        (*write doesn't matches level*)
+        else Set'(var, result_body)
+     
+      | Var'(VarFree(str)), expr -> Set'(Var'(VarFree(str)), box_get_set_body level arg expr)
+      | other -> body
+      )
+    | BoxSet'(var, expr) -> BoxSet'(var, box_get_set_body level arg expr)
+          
+          
+            
+    | If'(test, dit, dif) -> If'(box_get_set_body level arg test, box_get_set_body level arg dit, box_get_set_body level arg dif)
+    | Seq'(expr_list) -> Seq'(List.map (box_get_set_body level arg) expr_list)
+    | Or'(expr_list) -> Or'(List.map (box_get_set_body level arg) expr_list )
+    | Applic'(expr, expr_list) -> Applic'((box_get_set_body level arg) expr,List.map (box_get_set_body level arg) expr_list)
+    | ApplicTP'(expr, expr_list) -> ApplicTP'((box_get_set_body level arg) expr,List.map (box_get_set_body level arg) expr_list)
+    | LambdaSimple'(arg_list, inner_body) -> LambdaSimple'(arg_list, (box_get_set_body (level+1) arg) inner_body)
+    | LambdaOpt'(arg_list, opt_arg, inner_body) -> LambdaOpt'(arg_list, opt_arg, (box_get_set_body (level+1) arg) inner_body)
+    | Def'(expr_var, expr_val) -> raise X_syntax_error
+    | other -> body;;
+
+let handle_arg minor arg body = 
+    let need_boxing read_list write_list = 
+    let rec need_boxing_rec ls1 ls2 = 
+    (match ls1, ls2 with
+      | [], [] -> false
+      | [] , other -> true
+      | other , [] -> true
+      | arg1::rest1, arg2::rest2 -> if (List.mem arg1 ls2) 
+                                    (*arg1 is in l2*)
+                                        (*arg1 is in l2 AND arg2 is in l1*)
+                                        then (false || need_boxing_rec rest1 (List.filter (fun a -> a!=arg1) ls2)) 
+                                        (*arg1 is in l2 AND arg2 is NOT in l1*)
+                                        else true ) in
+    match read_list, write_list with
+    | [] , other -> false
+    | other , [] -> false
+    | non_empty1, non_empty2 -> need_boxing_rec non_empty1 non_empty2 in
+
+  let fathers = find_fathers minor arg body in
+
+    match fathers with
+  | [read_list;write_list] ->  if need_boxing read_list write_list then true else false
+  | other -> false
+
+let box_set_lambda arg_list body =
+
+  let rec args_to_set_box_list minor arg_list body = match arg_list with
+    | car :: cdr -> 
+    let needs_boxing = handle_arg minor car body in if needs_boxing 
+      then
+          let set_box_car = Set'(Var'(VarParam(car, minor)), Box'((VarParam(car, minor)))) in
+          let set_box_cdr = args_to_set_box_list (minor+1) cdr body in ([set_box_car] @ set_box_cdr)
+
+      else args_to_set_box_list (minor+1) cdr body
+    | [] -> [] in
+  
+
+  let rec box_get_set_all_args minor arg_list rec_body = match arg_list with
+    | car :: cdr -> 
+    let needs_boxing = handle_arg minor car body in if needs_boxing 
+      then let new_body = box_get_set_body (-1) car rec_body in box_get_set_all_args (minor + 1) cdr new_body
+      else box_get_set_all_args (minor + 1) cdr rec_body
+    | [] -> rec_body in
+
+  let set_box_list = args_to_set_box_list 0 arg_list body in
+  let new_body = box_get_set_all_args 0 arg_list body in
+  match set_box_list with
+  | [] -> body
+  | list -> Seq'(set_box_list@[new_body])
+
+   ;;
+
+let rec box_set_rec e = match e with
+  | If'(test, dit, dif) -> If'(box_set_rec test, box_set_rec dit, box_set_rec dif)
+  | Seq'(expr_list) -> Seq'(List.map box_set_rec expr_list)
+  | Set'(expr_var, expr_val) -> Set'(box_set_rec expr_var,box_set_rec expr_val)
+  | Def'(expr_var, expr_val) -> Def'(box_set_rec expr_var,box_set_rec expr_val)
+  | Or'(expr_list) -> Or'(List.map box_set_rec expr_list)
+  | Applic'(expr, expr_list) -> Applic'(box_set_rec expr, List.map box_set_rec expr_list) 
+  | ApplicTP'(expr, expr_list) -> ApplicTP'(box_set_rec expr, List.map box_set_rec expr_list) 
+  | LambdaSimple'(arg_list, body) -> LambdaSimple'(arg_list,box_set_rec (box_set_lambda arg_list body))
+  | LambdaOpt'(arg_list, opt_arg, body) -> LambdaOpt'(arg_list, opt_arg, box_set_rec (box_set_lambda (arg_list@[opt_arg]) body))
+  | other -> other;; 
+
+let annotate_lexical_addresses e = annotate_lexical_rec e;;
+
+let annotate_tail_calls e = annotate_tail_rec false e;;
+  
+let box_set e = box_set_rec e;;
 
 let run_semantics expr =
   box_set
     (annotate_tail_calls
        (annotate_lexical_addresses expr));;
-  
+
 end;; (* struct Semantics *)
diff --git a/tag-parser.ml b/tag-parser.ml
index 712f408..10de009 100644
--- a/tag-parser.ml
+++ b/tag-parser.ml
@@ -1,6 +1,16 @@
 #use "reader.ml";;
+open Reader;;
 
-type constant =
+type constant = 
+(*
+quoted and unquoted: Pair(Symbol(name), Pair(sexpr, Nil())
+booleans
+chars
+numbers
+strings
+tag def -> field is always a const. if the field is quote, it should not appear in the Const we generate.
+tag ref
+*)
   | Sexpr of sexpr
   | Void
 
@@ -44,12 +54,16 @@ let rec expr_eq e1 e2 =
                        
 exception X_syntax_error;;
 
-module type TAG_PARSER = sig
+module type TAG_PARSER = 
+sig
   val tag_parse_expression : sexpr -> expr
   val tag_parse_expressions : sexpr list -> expr list
-end;; (* signature TAG_PARSER *)
+end;; 
+(* signature TAG_PARSER *)
 
-module Tag_Parser : TAG_PARSER = struct
+module Tag_Parser 
+(* : TAG_PARSER  *)
+= struct
 
 let reserved_word_list =
   ["and"; "begin"; "cond"; "define"; "else";
@@ -59,9 +73,268 @@ let reserved_word_list =
 
 (* work on the tag parser starts here *)
 
-let tag_parse_expression sexpr = raise X_not_yet_implemented;;
+let rec convert_pairs_to_list sexpr = match sexpr with
+| Pair(car, cdr) -> List.append [car] (convert_pairs_to_list cdr)
+| Nil -> []
+| other -> [other]
 
-let tag_parse_expressions sexpr = raise X_not_yet_implemented;;
+let rec convert_pairs_to_str_list sexpr = 
+  let flat_list = convert_pairs_to_list sexpr in
+  List.map (fun e -> match e with
+  |Symbol(str)->str
+  |_ -> raise X_syntax_error)
+   flat_list;;
+
+let rec check_arg_reoccurrence lst = 
+  let rec check_if_args_exists arg rest = match rest with
+  | car :: cdr -> if car = arg then true else check_if_args_exists arg cdr
+  | [] -> false in
+match lst with
+| car :: cdr -> if (check_if_args_exists car cdr) then true else check_arg_reoccurrence cdr
+| [] -> false
+
+
+let rec is_proper_list sexpr = match sexpr with
+    | Pair(car, cdr) -> is_proper_list cdr
+    | Nil -> true
+    | _ -> false
+
+let get_first_element lst = match lst with
+    | car :: cdr -> car
+    | [] -> "empty list";;
+
+let get_last_element lst = 
+    let rev_lst = List.rev lst in match rev_lst with
+    | car :: cdr -> car
+    | [] -> "empty list";;
+
+let rec remove_last_element lst = match lst with
+    | [x] -> []
+    | car :: cdr -> List.append [car] (remove_last_element cdr)
+    | [] -> [];;
+
+let rec remove_first_element lst = match lst with
+| [x] -> []
+| car :: cdr -> cdr
+| [] -> [];;
+
+let tag_parse_var str = 
+      let is_reserved_word = List.mem str reserved_word_list in
+          if is_reserved_word then raise X_syntax_error else Var(str);;
+
+let rec ribs_to_var_list ribs = match ribs with
+| Pair(Symbol v, _) -> Pair(Symbol v, Nil)
+| Pair(Pair(Symbol v, _), rest) -> Pair(Symbol v, (ribs_to_var_list rest))
+| Nil -> Nil
+| _ -> raise X_syntax_error;;
+
+let rec ribs_to_val_list ribs = match ribs with
+| Pair(Symbol _,Pair( sexpr , Nil)) -> Pair(sexpr, Nil)
+| Pair(Pair(Symbol _,Pair(sexpr,Nil)), rest) -> Pair(sexpr, (ribs_to_val_list rest))
+| Nil -> Nil
+| _ -> raise X_syntax_error;;
+
+let rec change_to_whatever ribs = match ribs with
+| Pair(Symbol e,Pair( sexpr , Nil)) ->  Pair(Symbol e, Pair(Symbol("quote"), Pair(Symbol("whatever"), Nil)))
+| Pair(Pair(Symbol e,Pair(sexpr,Nil)), rest) -> 
+  Pair(Pair(Symbol e,Pair(Pair(Symbol("quote"), Pair(Symbol("whatever"), Nil)),Nil)), (change_to_whatever rest))
+| Nil -> Nil
+| _ -> raise X_syntax_error;;
+
+let rec wrap_ribs_in_set ribs body = match ribs with
+|Pair(Pair(var,Pair(sexpr_val, Nil)),Nil) -> Pair(Pair(Symbol "set!", Pair(var, Pair(sexpr_val, Nil))), body)
+|Pair(Pair(var,Pair(sexpr_val,Nil)), rest) -> Pair(Pair(Symbol "set!", Pair(var, Pair(sexpr_val, Nil))), (wrap_ribs_in_set rest body))
+|Nil -> body
+| _ -> raise X_syntax_error;;
+
+
+let get_first_pair pairs = match pairs with
+    | Nil -> Nil
+    | Pair(car, cdr) -> car
+    | _ -> raise X_syntax_error
+
+let remove_first_pair pairs = match pairs with
+    | Nil -> Nil
+    | Pair(car, cdr) -> cdr
+    | _ -> raise X_syntax_error
+
+let rec parse_exp sexpr = match sexpr with
+(*constants*)
+  | Nil -> Const(Void)
+  | Bool(e) -> Const(Sexpr(Bool(e)))
+  | Char(e) -> Const(Sexpr(Char(e)))
+  | Number(e) -> Const(Sexpr(Number(e)))
+  | String(e) -> Const(Sexpr(String(e)))
+  | Pair(Symbol("quote"), Pair(e, Nil)) -> Const(Sexpr(e))
+  | Pair(Symbol("quasiquote"), Pair(e, Nil)) -> parse_exp (expand_quasiquote e)
+  | TagRef(e) -> Const(Sexpr(TagRef(e)))
+  | TaggedSexpr(e,Pair(Symbol "quote", Pair(x, Nil))) -> Const(Sexpr(TaggedSexpr(e, x)))
+  | TaggedSexpr(e,Bool(x)) -> Const(Sexpr(TaggedSexpr(e, Bool(x))))
+  | TaggedSexpr(e,Char(x)) -> Const(Sexpr(TaggedSexpr(e, Char(x))))
+  | TaggedSexpr(e,Number(x)) -> Const(Sexpr(TaggedSexpr(e, Number(x))))
+  | TaggedSexpr(e,String(x)) -> Const(Sexpr(TaggedSexpr(e, String(x))))
+  | TaggedSexpr(e,TagRef(x)) -> Const(Sexpr(TaggedSexpr(e, TagRef(x))))
+(*variables*)
+  | Symbol(e) -> tag_parse_var e
+(*conditionals*)        
+  | Pair(Symbol("if"), Pair(test, Pair(dit, dif))) -> tag_parse_if test dit dif
+
+  | Pair(Symbol("cond"), ribs) -> parse_exp (expand_cond ribs)
+(*lambdas*)
+  | Pair(Symbol("lambda"), Pair(args, body)) -> tag_parse_lambda args body
+  | Pair(Symbol "let", Pair(ribs, body)) -> parse_exp (expand_let ribs body)
+  | Pair(Symbol "let*", Pair(ribs, body)) -> parse_exp (expand_let_star ribs body)
+  | Pair(Symbol "letrec", Pair(ribs, body)) -> parse_exp (expand_letrec ribs body)
+  (* Const(Sexpr((expand_let ribs body))) *)
+  (*or*)
+  | Pair(Symbol "or", bool_pairs) -> tag_parse_or bool_pairs
+  | Pair(Symbol "and", bool_pairs) -> parse_exp (expand_and bool_pairs)
+  (*MIT define*)
+  | Pair(Symbol "define", Pair(Pair(name, args), body)) -> parse_exp (expand_mit_def name args body)
+  (*define*)
+  | Pair(Symbol "define", Pair(name, sexpr)) -> tag_parse_define name sexpr
+  (*set*)
+  | Pair(Symbol "set!", Pair(name, Pair(sexpr, Nil))) -> Set((parse_exp name), (parse_exp sexpr))
+  (*sequence*)
+  | Pair(Symbol "begin", seq) -> tag_parse_seq_explicit seq
+  (*applic*)
+  | Pair(proc_sexpr, sexprs) ->  tag_parse_applic proc_sexpr sexprs
+  | _ -> raise X_syntax_error
+
+  and tag_parse_if test dit dif = match dif with
+  | Nil -> If(parse_exp test, parse_exp dit, Const(Void))
+  | Pair(sexpr, Nil) -> If (parse_exp test, parse_exp dit, parse_exp sexpr)
+  |_ -> raise X_syntax_error
+
+  and tag_parse_define name sexpr = match sexpr with
+  | Nil ->  Def((parse_exp name), Const(Void))
+  | Pair(a, Nil)-> Def((parse_exp name), (parse_exp a))
+  | other -> raise X_syntax_error
+
+  and tag_parse_lambda args body =
+  let body_seq = (tag_parse_seq_implicit body) in
+   match args with
+      | Pair(car, cdr) -> let str_list = convert_pairs_to_str_list args in 
+        if (check_arg_reoccurrence str_list) then raise X_syntax_error;
+        if (is_proper_list args) then LambdaSimple(str_list, body_seq) else 
+        let lst_without_last_element = remove_last_element str_list in 
+        let last_element = get_last_element str_list in 
+        LambdaOpt(lst_without_last_element, last_element, body_seq)
+      | Symbol(str) -> LambdaOpt([], str, body_seq)
+      | Nil -> LambdaSimple([], body_seq)
+      | _ -> raise X_syntax_error
+
+  and tag_parse_or bool_pairs = match bool_pairs with
+  | Nil -> Const(Sexpr (Bool false))
+  | Pair (a,Nil) -> Const(Sexpr (a))
+  | Pair (a,b) -> let bool_list = List.map parse_exp (convert_pairs_to_list bool_pairs) in
+      Or(bool_list)
+  | _ -> raise X_syntax_error
+
+  and tag_parse_seq_explicit seq = match seq with 
+  | Nil -> Const Void
+  | Pair(a, Nil) -> parse_exp a
+  | Pair(a, b) -> let seq_expr = List.map parse_exp (convert_pairs_to_list seq) in Seq(seq_expr)
+  | _ -> raise X_syntax_error
+  
+   and tag_parse_seq_implicit seq = match seq with 
+  | Pair(a, Nil) -> parse_exp a
+  | Pair(a, b) -> let seq_expr = List.map parse_exp (convert_pairs_to_list seq) in Seq(seq_expr)
+  | _ -> raise X_syntax_error
+
+  and tag_parse_applic proc_sexpr sexprs =   
+    let proc_expr = parse_exp proc_sexpr in
+    let exprs = 
+    List.map parse_exp (convert_pairs_to_list sexprs) in
+    (* [Const(Sexpr(sexprs))] in     *)
+    Applic(proc_expr, exprs)
+
+  and expand_quasiquote e = match e with
+  | Pair(Symbol("unquote"), Pair(sexpr, Nil)) -> sexpr
+  | Pair(Symbol("unquote-splicing"), Pair(sexpr, Nil)) -> raise X_syntax_error
+  | Pair(Pair(Symbol("unquote-splicing"), Pair(sexpr, Nil)), x) -> Pair(Symbol("append"),Pair(sexpr,Pair((expand_quasiquote x),Nil)))
+  | Pair(x, Pair(Symbol("unquote-splicing"), Pair(sexpr, Nil))) -> Pair(Symbol("cons"),Pair((expand_quasiquote x),Pair(sexpr,Nil)))
+  | Pair(x, y) -> Pair(Symbol("cons"),Pair((expand_quasiquote x), Pair((expand_quasiquote y),Nil)))
+  | Nil -> Pair(Symbol("quote"), Pair(Nil, Nil))
+  | Symbol(x) -> Pair(Symbol("quote"), Pair(Symbol(x), Nil))
+  | other -> other
+
+  and expand_cond ribs = match ribs with
+  (*3rd form*)
+  | Pair(Pair(Symbol "else",seq), _) -> (Pair(Symbol("begin"),seq))
+  (*2nd form*)
+  | Pair(Pair(test, Pair(Symbol("=>"), Pair(expr_f, Nil))), Nil) -> 
+      Pair(Symbol "let", Pair(Pair(Pair(Symbol "value", Pair(test, Nil)),
+       Pair(Pair(Symbol "f", Pair(Pair(Symbol "lambda", Pair(Nil, Pair(expr_f, Nil))), Nil)), Nil)),
+        Pair(Pair(Symbol "if", Pair(Symbol "value", Pair(Pair(Pair(Symbol "f", Nil),
+         Pair(Symbol "value", Nil)), Nil))), Nil))) 
+
+  | Pair(Pair(test, Pair(Symbol("=>"), Pair(expr_f, Nil))), rest) -> let expanded_ribs = (expand_cond rest) in
+   Pair(Symbol "let", Pair(Pair(Pair(Symbol "value", Pair(test, Nil)), 
+   Pair(Pair(Symbol "f", Pair(Pair(Symbol "lambda", Pair(Nil, Pair(expr_f, Nil))), Nil)),
+    Pair(Pair(Symbol "rest", Pair(Pair(Symbol "lambda", Pair(Nil, Pair(expanded_ribs, Nil))), Nil)), Nil))),
+     Pair(Pair(Symbol "if", Pair(Symbol "value", Pair(Pair(Pair(Symbol "f", Nil), Pair(Symbol "value", Nil)),
+      Pair(Pair(Symbol "rest", Nil), Nil)))), Nil))) 
+  (*1st form*)
+  | Pair(Pair(test, seq), Nil) -> Pair(Symbol("if"), Pair(test, Pair(Pair(Symbol("begin"),seq), Nil)))
+  | Pair(Pair(test, seq), rest) -> let expanded_ribs = (expand_cond rest) in
+    (Pair(Symbol("if"), Pair(test , Pair(Pair(Symbol("begin"),seq) , Pair(expanded_ribs , Nil)))))
+  | _ -> raise X_syntax_error  
+
+  and expand_let ribs body = 
+  let var_list = ribs_to_var_list ribs in 
+  let val_list = ribs_to_val_list ribs in
+  let lambda_sexpr = Pair(Symbol("lambda"), Pair(var_list, body)) in
+  Pair(lambda_sexpr, val_list)
+
+  and expand_let_star ribs body = 
+    let rec handle_let_star_body rec_ribs rec_body vars vals =
+          match rec_ribs with
+        | Nil -> expand_let rec_ribs rec_body
+        | Pair(rib, Nil) -> expand_let rec_ribs rec_body
+        | Pair(rib, rest) ->
+        (
+          let first_var = Pair((get_first_pair vars),Nil) in 
+          let first_val = Pair((get_first_pair vals),Nil) in
+          let rest_vars = remove_first_pair vars in
+          let rest_vals = remove_first_pair vals in
+          let body = handle_let_star_body rest body rest_vars rest_vals in
+          let lambda_sexpr = Pair(Pair(Symbol("lambda"), Pair(first_var, Pair(body, Nil))),first_val) in
+          lambda_sexpr
+      )
+        | _ -> raise X_syntax_error in
+    let var_list = ribs_to_var_list ribs in 
+    let val_list = ribs_to_val_list ribs in
+    handle_let_star_body ribs body var_list val_list
+
+  and expand_letrec ribs body = match ribs with
+  | Nil -> expand_let ribs body
+  | Pair(rib, rest) -> 
+    let new_ribs = change_to_whatever ribs in
+    let set_body = wrap_ribs_in_set ribs body in
+    (* let l_body = Pair(Symbol "let", Pair(Nil, body)) in *)
+    let form = Pair(Symbol "let", Pair(new_ribs,set_body)) in
+    (* let complete_form = Pair(Symbol "let", Pair(new_ribs,new_body)) in *)
+    form
+  | _ -> raise X_syntax_error
+
+  and expand_and bool_pairs = match bool_pairs with
+  | Nil -> Bool(true)
+  | Pair(expr,Nil) -> expr
+  | Pair(expr1, rest) -> let dit = (expand_and rest) in
+    Pair(Symbol("if"), Pair(expr1, Pair(dit, Pair(Bool(false), Nil))))
+  | _ -> raise X_syntax_error
+
+  and expand_mit_def name args body = 
+  let lambda_form = Pair(Symbol "lambda", Pair(args, body)) in
+  let form = Pair(Symbol "define", Pair(name, Pair(lambda_form,Nil))) in form
+;;
+
+
+
+let tag_parse_expression sexpr = parse_exp sexpr;;
+
+let tag_parse_expressions sexpr = List.map parse_exp sexpr;;
 
   
-end;; (* struct Tag_Parser *)
+end;; (* struct Tag_Parser *)
\ No newline at end of file
